## TDDの概念
- 良いコードは動作するきれいなコード
- 設計をきれいにして最終的に動作するゴールを作るのがこれまでのソフトウェア工学
- いざ動作させてみると動かないとか多い
  - 仕様が多すぎる
  - コードが遅い
  - etc...
- 動作するコードの情報量が多い。現在では。
- ソフトウェア開発は工学になりきれていない（変更可能性が高い？）
- とにかく動くコードは、きれいにしていくうちで動かなくなる可能性を孕んでいて、とくに大規模だと嫌煙されてしまう
- TDDは動作するままきれいにしていくを狙う


## TDDのやりかた
- RED -> Green -> Refactor
  - 今までRefactorの段階を考えてなかったなー
  - 1 commit毎にやるときはrebaseしてまとめる？
    - Red でコミット Greenでコミット Refactorでコミットという小さい粒度でやるらしい。Refactorは意味のある単位でcommitを分ける
  - Refactorは時間をキメてやったりする
- やることを洗い出してやりやすいやつからやる
  - どのくらいの粒度のリスト感にするかが重要そう
- Refactoringはよく軽視されてしまうので（速度、堕落、後回し）。強い志が必要
  - コードをきれいに保つのはRefactoringのみ


## Refactoring
  - 実際Refactoringの時間が外部要因で取れない・取りにくい場合どう説得すれば良い？
  - リファクタリングの呪い（やられにくくなる）
    - 独立したタスクにすると大事になってしまう。
    - 日々のタスクのなかでやるのが一番よさそう


## テスト
- TDDはユニットテスト
- https://robots.thoughtbot.com/four-phase-test
- 最初は検証からやる。four phase testに従って動くレベルまでテストを書く
- テストコード<->実装コードを互いにテストし合う関係
  - ミューテーションテスティング？
- 実装コードで仮実装をすることでテストのテストをしている。( ex return "1" みたいな)
- testメソッドを増やすかアサーションを増やすか？基本は前者
  - アサーションだと途中でテストが終わってしまう
  - 情報量が減ってしまう
  - assertionが複数あるとテスト対象がブレる
  - 何で落ちたかが明瞭
- リファクタリングは実装とテストコード
- テストがある程度整ってきたら、テストに仕様を含ませる（入れ子にする？）
  - 何か変更するときには一気に変えないってのが基本的なやりかたっぽいｎ
- テストに意味がないのであれば消す、増やすでも良い（仮実装でやったものとか）
  - テストは後からみたときに対称性がないと意味を考えてしまう？
  - テストの対象性は担保すべき項目っぽい
  - テストは消しにくいので、最初に書いた人がリファクタリングしていかないとメンテナンス性が落ちる
  - 3年後新人が見たときに意図が伝わるかが大事な気がしてきた

## まとめ
- テストは歩幅を調整する
  - test -> 仮実装 -> 三角実装 -> 実装
  - test -> 仮実装 -> 実装
  - test -> 明白な実装
  - 三角測量：テストのテスト。実装から見たテストコードの正しさ？を確認する
