## Auto scalingとは
EC2インスタンスを動的に増減が可能な機能。負荷状況に応じて増やしたり、あるインスタンスで障害が起きた時、自動で新しいインスタンスを構築できたりできる。

* インスタンスの異常を検知して、新しいインスタンスを起動でき耐障害性が向上する。
* 一つのAZが起動できなくなると、もう一方のAZに移る。
* コストの削減。必要な分だけインスタンスを立てることができる。

## Auto scalingの機能
### 複数AZへのインスタンス分散
一つのAZが起動できなくなると、もう一方のAZに移る。その後、復旧するとAZ間でインスタンス数を分散させようとする。注意が必要かも。

### 起動設定(Launch configuration)
起動時のAMIやインスタンスタイプなどを設定できる。起動中のインスタンスを使用して設定を作成することもできる。

設定できるのは下記
* AMI
* インスタンスタイプ
* spot intanceの利用有無
* IAM role
* CloudWatchでのMonitoring
* User dataの指定
* IP Addressの割当指定。publicIPを与えるとか
* Volumeの指定。追加も可能
* Security Groupの指定


### グループ(Auto scaling group)

EC2インスタンスの集合。1つの起動設定を指定できる。インスタンス終了時のライフサイクルなどを指定できる。

利用するには名前と最大許容数と最小許容数だけでよいがあまり意味がない。下記の設定もしたほうがいい。

* 希望する容量
* 複数AZを利用するような設定
* 起動設定を指定
* メトリックスとヘルスチェック指定をしてスケールアウト、インの指定と障害の検知を決めるべき

設定できる項目は下記

* Launch Configuration
* Groupの名前
* 希望するインスタンス数
* 利用するサブネット（複数選択可能）
* ELBの指定
* ヘルスチェックの猶予期間。インスタンスが起動してから何秒待つか
* CloudWatchでのMonitoring
* スケールイン時のインスタンス保護。これを設定すると勝手にterminateされなくなる
* スケールアウト・イン時の指定
* 通知設定。インスタンスの起動成功、起動失敗、終了、終了失敗など指定されたタイミングで通知できる
* タグ

#### ライフサイクルフック
インスタンスの起動・終了時などに特定のイベントをフックできる

Pending:Wait/Terminating:Waitの間にイベントが実行される。この時間はデフォルトで1時間で、それを超えると、起動・終了状態になる。

##### 待機時間
先ほどの通りデフォルトでは3600秒。待機状態は`RecordLifecycleActionHeartbeat`などを使うことで最大48時間まで調整できる。その他Heartbeatでタイムアウト値を定義したり、`CompleteLifecycleAction`を使うことで即座に待機を終わらせることができる。

#### その他できること
* 既存のインスタンスのアタッチ・デタッチ
* 複数AZのマージ
* 一時的にインスタンスを削除


### スケーリングプラン
#### クールダウン
ClowdWatchのアラームをCPUの90%にしたとして、アラートが起きた場合にインスタンスが起動するが、利用できるようになるまでに数分かかる。その間もアラートが来ると、再度インスタンスを起動させようとしてしまうがそういったものを防ぐ仕組みがクールダウン。クールダウン中は他のアクションが実行されない。

#### 終了時の挙動
どのインスタンスを終了させるかポリシーで指定が可能

* `OldestInstance`:最も古いインスタンスを終了。徐々に置き換えるときに。
* `NewestInstance`:最も新しいインスタンスを終了。新しいものの起動テストとかに。
* `OldestLaunchCofiguration`:最も古い起動設定を終了。古い設定を置き換えるときに。
* `ClosestToNextInstanceHour`:次の課金時間に一番近いものを。コスト削減に。
* `Default`:デフォルトの終了ポリシーを利用。複数のポリシーがある場合に。

#### ヘルスチェックについて
デフォルトでは、インスタンスステータスが`running`以外、システムステータスが`impaired`である場合は異常とみなす。

ELBのヘルスチェックを利用する場合は、OutofServiceだと異常とみなす。

#### スケーリング
事前に予測してスケーリングプランを設定できる。コンソールから設定可能。


## 使いドコロを考える
auto scalingでのヘルスチェックと、アプリケーションとしてのヘルスチェックが同期されていることが好ましいと思われる。Auto hearlingにより新しいインスタンスが出来たり、再分散によってAZの平均を取ろうとするので、インスタンス起動＝サービスインが前提になっている気がする。

## Terraformでの使い方
Terraformでは5つのリソースをサポートしている
* [AWS: aws_autoscaling_group - Terraform by HashiCorp] (https://www.terraform.io/docs/providers/aws/r/autoscaling_group.html)
* [AWS: aws_autoscaling_lifecycle_hook - Terraform by HashiCorp] (https://www.terraform.io/docs/providers/aws/r/autoscaling_lifecycle_hooks.html)
* [AWS: aws_autoscaling_notification - Terraform by HashiCorp] (https://www.terraform.io/docs/providers/aws/r/autoscaling_notification.html)
* [AWS: aws_autoscaling_policy - Terraform by HashiCorp] (https://www.terraform.io/docs/providers/aws/r/autoscaling_policy.html)
* [AWS: aws_autoscaling_schedule - Terraform by HashiCorp] (https://www.terraform.io/docs/providers/aws/r/autoscaling_schedule.html)

### aws_autoscaling_group
auto scaling groupの設定。この設定が基本で、launch_configurationで各インスタンスの起動時の挙動を決め、こちらでグループ全体の設定を定義する

### aws_autoscaling_lifecycle_hook

### aws_autoscaling_notification

### aws_autoscaling_policy


### aws_autoscaling_schedule
スケジュールの設定。特定時間帯で台数を変更するなどの設定をする。

#### start_time/end_time
スケジュールの時間を設定する。

#### recurrent
cronのフォーマットで時間を設定する。こっちを使えば、繰り返し処理（週末は台数減らすなど）の処理ができる。両方合わせて使用すると、recurrentの開始、終了をstart_time/end_timeが指し示すと思われる（未検証）

## 注意点
* auto scalingを使うにはcloudwatchの詳細モニタリングの利用が必須で、インスタンスあたり、毎月$3.5かかる。

## スケーリング
スケーリングは4つ

- 現在のインスタンスレベルの常時維持
- 手動スケーリング
- スケジュールに基づくスケーリング
- 要求に基づくスケーリング

スケーリングポリシーは複数アタッチすることができる。複数のポリシーが同時に指示する場合は、ASに最大の影響を与えるポリシーが選択される（より影響が大きい方。例えばインスタンスを1台増やすよりも2台増やす方を優先する）

### インスタンス数の維持
常時ヘルスチェックを行い、正常でないインスタンスは終了され、新しいインスタンスが起動される。インスタンスにEIP/EBSボリュームがある場合自動で解除されてしまうので、手動でつけ直す必要がある

### 手動スケーリング

### スケジュールに基づくスケーリング
注意点は下記

- スケジュールの実行順序は同じグループ内でのみ有効。複数のグループ間で実行される場合は保証されない
- スケジュールされたオペレーションはは通常数秒で実行されるが、アクション（実際の起動とか？）は最大2分程度遅れる可能性がある。実行順に従ってアクションを実行するのでさらに遅れる可能性がある
- スケジュールアクションは同時間帯に複数実行できない。
- クールダウン期間はサポートされない

設定はcron形式などで記述できる

### 動的なスケーリング
CPUなどのリソース状況に応じてスケーリングが可能

- Simple scaling: １つのスケーリング調整値にもとづいてグループの現在の容量を増減
- Step scaling: アラーム超過のサイズに応じて変動する一連のスケーリング調整値に基づく
- Target tracking scaling： 特定のメトリクスのターゲット値にもとづいて増減

### 簡易スケーリングとステップスケーリング
#### 簡易スケーリング
スケーリングアクティビティが開始されると、ポリシーはスケーリングアクティビティまたはヘルスチェック交換が完了し、クールダウンが終了するまで他のアラームを受け取れない

#### ステップスケーリング
簡易スケーリングと違いスケーリングアクティビティ中でも他のアラームを受け取れる。ウォームアップを指定できる。クールダウンはサポートされていない

#### スケーリング調整タイプ
ASGの容量の変更方法を定義

- ChangeInCapacity: 指定したインスタンス数だけ現在のグループの容量を増減する（相対値）
- ExactCapacity: 指定したインスタンス数にグループの容量を変更（絶対値）
- PercentChangeInCapacity: 指定したパーセンテージだけ現在の容量を増減。
  - x > 1の場合, 小数点切り捨て 12.7 -> 12
  - 0 < x < 1, 1に丸める 0.67 -> 1
  - -1 < x < 0, -1に丸める -.58 -> -1
  - x < -1, 小数点切り捨て, -6.67 -> -6

#### ウォームアップ
ウォームアップ期間が終わるまではAuto Scalingグループの集合メトリクスの対象にはならない

### ターゲットの追跡スケーリング
負荷パターンに合わせて調整することができる

- ターゲットの追跡スケーリングポリシーを設定して、Auto Scalingグループの平均集計CPU使用率を50%に維持する
- ALBターゲットグループのターゲットごとのリクエスト数を、1000に維持する

すべてのメトリクスデータを使えるわけではない。インスタンスの使用頻度が見えないとだめ
下記はだめな例

- LBによって受信されたリクエスト数。ASGのグループの使用率によって変わらないから
- LBのレイテンシー。使用率の増加により増える場合があるが、必ずしもではないため
- SQSのApproximateNumberOfMessagesVisible。ただし、メッセージがインスタンス間で分散される場合はできるかも

ASG間での均衡を保つために使える仕組みと考えるのがよさそう。

注意点

- メトリクスが十分にない場合スケールされない。CWにデータポイントがない場合などINSUFFICIENT_DATAのときにスケールインしたい場合は、簡易かステップポリシーを使ってINSUFFICIENT_DATAでスケールインするようにしないといけない
- 1分毎でのスケーリングよい
- 利用しているCWアラームが削除してはいけない

### Amazon SQSに基づくスケーリング
ApproximateNumberOfMessagesVisibleを監視してworkerの処理が追いついてないときは、workderを増やすとよさそう。ECSでもできそう

### クールダウン
スケーリングのクールダウン中はスケーリングポリシーが停止する。スケーリング固有のクールダウンで一般的な使い方は、スケールインポリシーでの利用。default 300 秒だが、クールダウン を180秒とかにすることでコストの削減につながる

#### クールダウンと複数インスタンス
複数のインスタンスの場合、最後のインスタンスが起動するとクールダウン期間が有効になる

### スケールイン時にAuto Scalingがどのインスタンスを終了するかを制御する
デフォルトでは各AZで均等になるようにする

1. AZの数を確認。スケールインから保護されていないAZを選択する。同数の場合、一番古い起動設定を使用するものを選択
2. 選択したAZで保護されていないどのインスタンスが最も古い起動設定を使用しているかを判断する
3. 最も古い起動設定が複数ある場合、次の課金時間に最も保護されていないインスタンスを判断する
4. 3が複数ある場合ランダム

#### 終了ポリシーのカスタマイズ
終了ポリシーはカスタマイズできる。ただしAZ間での不均衡がある場合はそこに対して終了ポリシーを適用する。均衡な場合は全体で見る？

- OldestInstance: 最も古いインスタンスを終了。アップグレードするときに便利
- NewestInstance: 最も新しいインスタンスを終了。テスト目的で本番では使わないほうがよい
- OldestLaunchCofiguration: 最も古い起動設定のインスタンスを終了。以前の設定を使用しているインスタンスを廃止する場合に便利
- ClosestToNextInstanceHour: Auto Scalingは次の課金時間に最も近いインスタンスを終了。コスト管理を重視するなら有用
- Default

## Link
* [What Is Auto Scaling? - Auto Scaling] (http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/WhatIsAutoScaling.html)
* [【AWS】Auto Scalingまとめ - Qiita] (http://qiita.com/iron-breaker/items/2b55da35429da7b19e49#auto-scaling%E3%81%AE%E8%A8%AD%E8%A8%88%E8%80%83%E6%85%AE%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88)
